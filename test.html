<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />

<!-- Provide a title.  This will be shown on the generated chart -->
<title>Demo Test Suite</title>

<script type="text/javascript" src="JSLitmus.js"></script>
<script type="text/javascript">
    'use strict';
    // Set up a simple array of colours
    var numberSmall = new Array (1,2,3,4,5,6,7,8,9,10);

    // Set up numbers from 1 to 2500
    var numbersHalf = new Array();
    
    for (var i = 1; i < 2500; i++) {
      numbersHalf.push(i);
    };

    // Set up numbers from 1 to 5000
    var numbersFull = new Array();
    
    for (var i = 1; i < 5000; i++) {
      numbersFull.push(i);
    };

    // Find modules
    function findModules5(item) {
        return item % 5 === 0 ;
    }

    JSLitmus.test('Get modules 5 on small array', function() {
        myFilter(numberSmall, findModules5);
    });
    
    JSLitmus.test('Get modules 5 on bigger array', function() {
        myFilter(numbersHalf, findModules5);
    });

    JSLitmus.test('Get modules 5 on big array', function() {
        myFilter(numbersFull, findModules5);
    });

    JSLitmus.test('Original: Get modules 5 on small array', function() {
        numberSmall.filter(findModules5);
    });
    
    JSLitmus.test('Original: Get modules 5 on bigger array', function() {
        numbersHalf.filter(findModules5);
    });

    JSLitmus.test('Original: Get modules 5 on big array', function() {
        numbersFull.filter(findModules5);
    });

    //filter - works with array numbers, object properties, string.
    const myFilter = (list, fn) => {
      const answer = [];
      if( typeof list.length != "undefined" ){
        for (let i = 0; i < list.length; i++) {
          if (fn(list[i])) {
            answer.push(list[i]);
          }
        }
      } else {
        if(typeof list === "object"){
          for(let prop in list){
            if(list.hasOwnProperty(prop) && fn(list[prop])){
              answer.push(list[prop]);
            }
          }
        }
      }
      return answer;
    };

    //reject works with strings, arrays, object props. Optimize for array of objects
      const myReject = (list, fn) => {
      const answer = [];
      if( typeof list.length != "undefined" ){
        for (let i = 0; i < list.length; i++) {
          if (!fn(list[i])) {
            answer.push(list[i]);
          }
        }
      } else {
        if(typeof list === "object"){
          for(let prop in list){
            if(list.hasOwnProperty(prop) && !fn(list[prop])){
              answer.push(list[prop]);
            }
          }
        }
      }
      return answer;
    };

      //partitition - works with strings, arrays... TODO - optimize for objects and arrays of objects.
      const myPartition = (list, fn) => {
      const truthyAns = [];
      const falsyAns  = [];
      const answer = [];
      if( typeof list.length != "undefined" ){
        for (let i = 0; i < list.length; i++) {
          if (fn(list[i])) {
            truthyAns.push(list[i]);
          } else {
            falsyAns.push(list[i]);
          }
        }
      } else {
        if(typeof list === "object"){
          for(let prop in list){
            if(list.hasOwnProperty(prop)){
              if(fn(list[prop])){
                truthyAns.push(list[prop]);
              } else {
                falsyAns.push(list[i]);
              }
            }
          }
        }
      }
      answer.push(truthyAns, falsyAns);
      return answer;
    };

    //every TODO test as on https://leanpub.com/lodashcookbook/read#leanpub-auto-every-and-some
      const myEvery = (list, fn) => {
        if( typeof list.length != "undefined" ){
          for (let i = 0; i < list.length; i++) {
            if (!fn(list[i])) {
              return false;
            }
          } return true;
        } else {
          if(typeof list === "object"){
            for(let prop in list){
              if(list.hasOwnProperty(prop) && !fn(list[prop])){
                return false;
              }
            } return true;
          }
        }
      };

      //some TODO test as on https://leanpub.com/lodashcookbook/read#leanpub-auto-every-and-some
      const mySome = (list, fn) => {
        if( typeof list.length != "undefined" ){
          for (let i = 0; i < list.length; i++) {
            if (fn(list[i])) {
              return true;
            }
          } return false;
        } else {
          if(typeof list === "object"){
            for(let prop in list){
              if(list.hasOwnProperty(prop) && fn(list[prop])){
                return true;
              }
            } return false;
          }
        }
      };



    const obj = {
      a: 1,
      b: 2,
      c: 3,
    };

    var fruits = [
  {
    "name": "apple",
    "price": 0.99,
    "onSale": true
  },
  {
    "name": "orange",
    "price": 1.99,
    "onSale": true
  },
  {
    "name": "passion fruit",
    "price": 4.99,
    "onSale": true
  }
]

    //   let resultMF = myEvery(fruits,(el) => el.onSale === true);
    //let resultMF = myPartition(fruits, 'onSale'); - TODO - update all function to support scenario if just a string is passed - in this case sort array. It can be either number or string. Sort hemogeneous array using merge search and perform binary search. 
    //http://web.mit.edu/16.070/www/year2001/handy.pdf
    //TODO - update filter and reject to also accept array of objects and search for specified property to be truthy or falsy...
    let resultMF = mySome(fruits,(el) => el.onSale === false);
    console.log(resultMF);
/*
// The empty form of a non-looping test.  This should result in "Infinity"
// operations per second, or very close to it.
JSLitmus.test('empty test (non-looping)', function() {});

// The empty form of a looping test.  This should also result in "Infinity"
// operations per second, or very close to it.
JSLitmus.test('empty test', function(count) {
  while (count--);
});

// Test how much overhead there is in invoking a function
var emptyFunction = function() {};
JSLitmus.test('function overhead (non-looping)', function() {
  emptyFunction();
});

// Test function invocation using a looping test.  This will be a bit faster
// both becasue it's a looping function, and because 'f' is local to the test
// function.
JSLitmus.test('function overhead', function(count) {
  var f = emptyFunction;
  while (count--) f();
});

// Test Array.join() method so we can see how it compares to the "+"
// operator
JSLitmus.test('"hello" + "world" (non-looping)', function() {
  var a = "hello", b = "world", x;
  x = a+b;
});

// Test Array.join() method so we can see how it compares to the "+"
// operator
JSLitmus.test('"hello" + "world"', function(count) {
  var a = "hello", b = "world", x;
  while(count--) x = a+b;
});

// Test Array.join() method so we can see how it compares to the "+"
// operator
JSLitmus.test('string join()', function(count) {
  var a = ['hello', 'world'];
  while (count--) a.join();
});

// Is Math.random() fast or slow?
JSLitmus.test('Math.random()', function(count) {
  while (count--) Math.random();
});

// How fast is a simple regex test()? Let's find out...
JSLitmus.test('RegExp.test()', function(count) {
  while (count--) /rl/.test('hello world');
});

// Hmm... does caching the regex out side of the iteration help?
JSLitmus.test('cached RegExp.test()', function(count) {
  var re = /rl/;
  while (count--) re.test('hello world');
});

// What about Date creation?  Is that fast or slow?
JSLitmus.test('new Date()', function(count) {
  while (count--) new Date();
});

// What if we set innerHTML to a Date?  Since this operation is pretty slow
// there's no need to implement this as a looping test.
JSLitmus.test('set Element.innerHTML', function() {
  document.getElementById('test_element').innerHTML = new Date();
});

// Test Array creation, so we can compare to other operations
JSLitmus.test('new Array()', function(count) {
  while (count--) {var a = [];}
});

*/
</script>
</head>

<body>
  <p>A simple demo showing how JSLitmus can be used to test the performance of some core JavaScript features. View source to see fully commented code.</p>
  <div id="test_element" style="overflow:hidden; width: 1px; height:1px;"></div>
</body>
</html>